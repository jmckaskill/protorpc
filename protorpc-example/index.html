<html>

<head>
    <script src="/index2.D4044292F0.js"></script>
    <script>


        // flags
        // bits 0-3 - base type
        // bit 4 - repeated
        // bit 5 - has extra decoder
        // 0/16 - bool
        // 1/17 - uint32
        // 2/18 - int32
        // 3/19 - sint32
        // 36/52 - enum
        // 5/21 - uint64
        // 6/22 - int64
        // 7/23 - sint64
        // 8/24 - fixed32
        // 9/25 - sfixed32
        // 10/26 - fixed64
        // 11/27 - sfixed64
        // 12/28 - float
        // 13/29 - double
        // 14/30 - string
        // 15/31/47/63 - bytes & msg

        var proto = (function () {
            // in these functions
            // v is a Uint8Array pointing to the original input buffer
            // r is an array of [current offset, current end]
            var get_varint = function (v, r) {
                var shift = 0;
                var ret = 0;
                while (r[0] < r[1]) {
                    var u = v.getUint8(r[0]);
                    ret |= (u & 0x7F) << shift;
                    r[0]++;
                    if ((u & 0x80) == 0) {
                        return ret >>> 0;
                    }
                    shift += 7;
                }
                throw new Error("invalid protobuf");
            };
            var get_varint_64 = function (v, r) {
                var shift = 0;
                var low = 0;
                var high = 0;
                while (r[0] < r[1]) {
                    var u = v.getUint8(r[0]);
                    var w = u & 0x7F;
                    if (shift > 32) {
                        high |= w << (shift - 32);
                    } else if (shift) {
                        low |= w << shift;
                        high |= w >>> (32 - shift);
                    } else {
                        low = w;
                    }
                    r[0]++;
                    if ((u & 0x80) == 0) {
                        return [low >>> 0, high >>> 0];
                    }
                    shift += 7;
                }
                throw new Error("invalid protobuf");
            };
            var skip = function (v, r, tag) {
                switch (tag & 7) {
                    case 0: // varint
                        while (r[0] < r[1] && (v.getUint8(r[0]) & 0x80)) {
                            r[0]++;
                        }
                        r[0]++;
                        break;
                    case 1: // fixed 64
                        r[0] += 8;
                        break;
                    case 2: // variable
                        r[0] += get_varint(v, r);
                        break;
                    case 5: // fixed 32
                        r[0] += 4;
                        break;
                }
                if (r[0] > r[1]) {
                    throw new Error("invalid protobuf");
                }
            };
            var get_varlen = function (v, r) {
                var len = get_varint(v, r);
                var ret = [r[0], r[0] + len];
                r[0] += len;
                return ret;
            };
            // utf.js - UTF-8 <=> UTF-16 convertion
            //
            // Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
            // Version: 1.0
            // LastModified: Dec 25 1999
            // This library is free.  You can redistribute it and/or modify it.
            var utf16to8 = function (str) {
                var out, i, len, c;

                out = [];
                len = str.length;
                for (i = 0; i < len; i++) {
                    c = str.charCodeAt(i);
                    if ((c >= 0x0001) && (c <= 0x007F)) {
                        out += str.charAt(i);
                    } else if (c > 0x07FF) {
                        out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
                        out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));
                        out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));
                    } else {
                        out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));
                        out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));
                    }
                }
                return out;
            }
            var utf8to16 = function (v, i, end) {
                var out = "";
                while (i < end) {
                    var c = v.getUint8(i++);
                    switch (c >> 4) {
                        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
                            // 0xxxxxxx
                            out += String.fromCharCode(c);
                            break;
                        case 12: case 13:
                            // 110x xxxx   10xx xxxx
                            var c2 = v.getUint8(i++);
                            out += String.fromCharCode(((c & 0x1F) << 6) | (c2 & 0x3F));
                            break;
                        case 14:
                            // 1110 xxxx  10xx xxxx  10xx xxxx
                            var c2 = v.getUint8(i++);
                            var c3 = v.getUint8(i++);
                            out += String.fromCharCode(((c & 0x0F) << 12) |
                                ((c2 & 0x3F) << 6) |
                                ((c3 & 0x3F) << 0));
                            break;
                        case 15:
                            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
                            // decode to unicode code point first
                            var c2 = v.getUint8(i++);
                            var c3 = v.getUint8(i++);
                            var c4 = v.getUint8(i++);
                            var u = ((c & 7) << 18) | ((c2 & 0x3F) << 12) | ((c3 & 0x3F) << 6) | (c4 & 0x3F);
                            // then encode to UTF-16
                            // UTF16 is shifted by 0x10000
                            u -= 0x10000;
                            // high surrogate 1101 10xx xxxx xxxx 
                            var high = 0xD800 | (u >> 10);
                            // low surrogate 1101 11xx xxxx xxxx
                            var low = 0xDC00 | (u & 0x3FF);
                            out += String.fromCharCode(high, low);
                            break;
                    }
                }
                return out;
            }
            var decode_u64 = function (low, high) {
                var rem = [];
                while (high) {
                    var rh = high % 10;
                    var qh = Math.floor(high / 10);
                    var xl = low + (rh * 4294967296);
                    var rl = xl % 10;
                    var ql = Math.floor(xl / 10);
                    rem.push(rl + 48 /*'0'*/);
                    low = ql;
                    high = qh;
                }
                while (low) {
                    var r = low % 10;
                    var q = Math.floor(low / 10);
                    rem.push(r + 48 /*'0'*/);
                    low = q;
                }
                rem.reverse();
                if (!rem.length) {
                    rem.push(48);
                }
                return String.fromCharCode.apply(null, rem);
            }
            var decode_s64 = function (low, high) {
                if (high >= 0x80000000) {
                    return "-" + decode_u64(0xFFFFFFFF - low + 1, 0xFFFFFFFF - high);
                } else {
                    return decode_u64(low, high);
                }
            }
            var decode_message;
            var decode_field = function (v, r, type, extra) {
                switch (type) {
                    case 0: // bool
                        return get_varint(v, r) != 0;
                    case 1: // uint32
                        return get_varint(v, r);
                    case 2: // int32
                        return get_varint(v, r) >> 0;
                    case 3: // sint32
                        // 0 -> 0, 1 -> -1, 2 -> 1, 3 -> -2
                        var u = get_varint(v, r);
                        return (u >>> 1) ^ -((u & 1) >> 0);
                    case 4: // enum
                        var u = get_varint(v, r);
                        return extra[u];
                    case 5: // uint64
                        var lh = get_varint_64(v, r);
                        return decode_u64(lh[0], lh[1]);
                    case 6: // int64
                        var lh = get_varint_64(v, r);
                        return decode_s64(lh[0], lh[1]);
                    case 7: // sint64
                        var lh = get_varint_64(v, r);
                        // equivalent to (u >> 1) ^ -(int64_t)(u & 1)
                        var low = lh[0];
                        var high = lh[1];
                        var mask = -(low & 1);
                        low = (((low >>> 1) | (high << 31)) ^ mask) >>> 0;
                        high = ((high >>> 1) ^ mask) >>> 0;
                        return decode_s64(low, high);
                    case 8: // fixed32
                        var ret = v.getUint32(r[0], true);
                        r[0] += 4;
                        return ret;
                    case 9: // sfixed32
                        var ret = v.getInt32(r[0], true);
                        r[0] += 4;
                        return ret;
                    case 10: // fixed64
                        var low = v.getUint32(r[0], true);
                        var high = v.getUint32(r[0] + 4, true);
                        r[0] += 8;
                        return decode_u64(low, high);
                    case 11: // sfixed64
                        var low = v.getUint32(r[0], true);
                        var high = v.getUint32(r[0] + 4, true);
                        r[0] += 8;
                        return decode_s64(low, high);
                    case 12: // float
                        var ret = v.getFloat32(r[0], true);;
                        r[0] += 4;
                        return ret;
                    case 13: // double
                        var ret = v.getFloat64(r[0], true);
                        r[0] += 8;
                        return ret;
                    case 14: // string
                        var rs = get_varlen(v, r);
                        return utf8to16(v, rs[0], rs[1]);
                    case 15: // bytes
                        var rs = get_varlen(v, r);
                        if (extra) {
                            return decode_message(extra, v, rs);
                        } else {
                            return new DataView(v.buffer, rs[0], rs[1] - rs[0]);
                        }
                }
            }
            var decode_packed = function (v, r, type, extra) {
                var rs = get_varlen(v, r);
                var ret = [];
                while (rs[0] < rs[1]) {
                    ret.push(decode_field(v, rs, type, extra));
                }
                return ret;
            };
            var decode_repeated = function (v, r, tag, type, extra) {
                var ret = [];
                for (; ;) {
                    ret.push(decode_field(v, r, type, extra));
                    var undo = r[0];
                    if (r[0] >= r[1] || get_varint(v, r) != tag) {
                        r[0] = undo;
                        return ret;
                    }
                }
            };
            var decode_message = function (fields, v, r) {
                var ret = {};
                var fidx = 0;
                var off = 0;
                while (r[0] < r[1] && fidx < fields.length) {
                    var want = fields[fidx++];
                    var type = fields[fidx++];
                    var undo = r[0];
                    var have = get_varint(v, r);
                    if (want < have) {
                        r[0] = undo;
                        fidx += (type & 32) ? 2 : 1;
                        continue;
                    } else if (have < want) {
                        skip(v, r, have);
                        continue;
                    }

                    var name = fields[fidx++];
                    var extra = (type & 32) ? fields[fidx++] : null;
                    var base = type & 15;

                    if ((type & 16) == 0) {
                        ret[name] = decode_field(v, r, base, extra);
                    } else if (base <= 13) {
                        ret[name] = decode_packed(v, r, base, extra);
                    } else {
                        ret[name] = decode_repeated(v, r, have, base, extra);
                    }
                }
                return ret;
            };
            var types = {};
            var add_types = function (pkgstr, msgs, enums) {
                // setup series of objects so that proto.types.com.example.TestMessage works
                var pkg = types;
                var parts = pkgstr.split(".");
                for (var i in parts) {
                    var part = parts[i];
                    var child = pkg[part];
                    if (!child) {
                        child = {};
                        pkg[part] = child;
                    }
                    pkg = child;
                }
                for (var name in msgs) {
                    pkg[name] = msgs[name];
                }
                for (var name in enums) {
                    pkg[name] = enums[name];
                }
            };
            return {
                decode: function (fields, buf) {
                    if (buf.buffer) {
                        // buf is a typed view or data view
                        return decode_message(fields, new DataView(buf.buffer), [buf.byteOffset, buf.byteOffset + buf.byteLength]);
                    } else {
                        // buf is an array buffer
                        return decode_message(fields, new DataView(buf), [0, buf.byteLength]);
                    }
                },
                add: add_types,
                types: types,
                utf8to16: utf8to16,
            };
        })();

        (function (proto) {
            var TestEnum = {
                [0]: "ENUM_A",
                [1]: "ENUM_B",
                [2]: "ENUM_C",
            };
            var TestPod = [
                8, 1, "u",
                16, 3, "i",
            ];
            var TestMessage = [
                8, 0, "b",    // 2
                16, 2, "i32",  // 5
                24, 3, "s32",  // 8
                37, 9, "sf32", // 11
                40, 1, "u32",  // 14
                53, 8, "f32",  // 17
                56, 6, "i64",  // 20
                65, 11, "sf64", // 23
                72, 7, "s64",  // 26
                80, 5, "u64",  // 29
                89, 10, "f64",  // 32
                101, 12, "f",   // 35
                105, 13, "d",   // 38
                114, 15, "by", // 41
                122, 14, "str",// 44
                128, 36, "en", TestEnum, // 48
                138, 47, "msg", null, // 52
                146, 47, "pod", TestPod, // 56
                170, 16, "rb", // 59
                178, 18, "ri32", // 62
                186, 19, "rs32", // 65
                194, 25, "rsf32", // 68
                202, 17, "ru32", // 71
                210, 24, "rf32", // 74
                218, 22, "ri64", // 77
                226, 27, "rsf64", // 80
                234, 23, "rs64", // 83
                1682, 21, "ru64", // 86
                1690, 26, "rf64", // 89
                1698, 28, "rf", // 92
                1706, 29, "rd", // 95
                1714, 31, "rby", // 98
                1722, 30, "rstr", // 101
                1730, 52, "ren", TestEnum, // 105
                1738, 63, "rmsg", null, // 109
                1746, 63, "rpod", TestPod, // 113
            ];
            TestMessage[52] = TestMessage;
            TestMessage[109] = TestMessage;
            var msgs = { TestMessage: TestMessage, TestPod: TestPod };
            var enums = { TestEnum: TestEnum };
            proto.add("com.example", msgs, enums);
        })(proto);

        var test_proto = new Uint8Array([
            // b = true
            0x08, 1,

            // i32 = -23 = 0xFFFFFFE9 = xF,x7F,x7F,x7F,x69
            0x10, 0xE9, 0xFF, 0xFF, 0xFF, 0xF,

            // s32 = -1234 = 2469 = 0x9A3 = 0x13,0x23
            0x18, 0xA3, 0x13,

            // sf32 = -34757 = 0xFFFF783B
            0x25, 0x3B, 0x78, 0xFF, 0xFF,

            // u32 = 1
            0x28, 1,

            // f32 = 34757 = 0x000087C5
            0x35, 0xC5, 0x87, 0, 0,

            // i64 = -3434565678781212898 = 0xD055F8B6567F571E = 1E 2E 7D 33 65 16 7E 2A 50 01
            0x38, 0x9E, 0xAE, 0xFD, 0xB3, 0xE5, 0x96, 0xFE, 0xAA, 0xD0, 0x01,

            // sf64 = -1234567890123456789 = 0x EEDD EF0B 8216 7EEB
            0x41, 0xEB, 0x7E, 0x16, 0x82, 0x0B, 0xEF, 0xDD, 0xEE,

            // s64 = -23585 = 47169 = xB841 = x02,x70,x41
            0x48, 0xC1, 0xF0, 0x02,

            // u64 = 10234 = 0x27FA = 0x4F,0x7A
            0x50, 0xFA, 0x4F,

            // f64 = 1234567890123456789 = 0x 1122 10F4 7DE9 8115
            0x59, 0x15, 0x81, 0xE9, 0x7D, 0xF4, 0x10, 0x22, 0x11,

            // f = 314 = 0x439d0000
            0x65, 0, 0, 0x9D, 0x43,

            // d = 3.141 = 0x4009 20C4 9BA5 E354
            0x69, 0x54, 0xE3, 0xA5, 0x9B, 0xC4, 0x20, 0x09, 0x40,

            // by = "abcde" = x61 x62 x63 x64 x65
            0x72, 5, 0x61, 0x62, 0x63, 0x64, 0x65,

            // str = "abc$¢€𝌆" = x61 x62 x63 x24 xC2A2 xE282AC xF09D8C86
            0x7A, 13, 0x61, 0x62, 0x63, 0x24, 0xC2, 0xA2, 0xE2, 0x82, 0xAC, 0xF0, 0x9D, 0x8C, 0x86,

            // en = ENUM_C = 2
            0x80, 1, 2,

            // msg = {b = true}
            0x8A, 1, 2, 0x8, 1,

            // pod = {i = -12}, -12 zigzag = 23
            0x92, 1, 2, 0x10, 23,

            // rb = [false,true,false]
            0xAA, 1, 3, 0, 1, 0,

            // ri32 = [-1,0,1] = [0xFFFFFFFF,0,1] = [xF x7F x7F x7F x7F, 0, 1]
            0xB2, 1, 7, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0, 1,

            // rs32 = [-10,0,10] = [19,0,20]
            0xBA, 1, 3, 19, 0, 20,

            // rsf32 = [-10,20,0] = [0xFFFFFFF6,20,0]
            0xC2, 1, 12, 0xF6, 0xFF, 0xFF, 0xFF, 20, 0, 0, 0, 0, 0, 0, 0,

            // ru32 = [1,2,3]
            0xCA, 1, 3, 1, 2, 3,

            // rf32 = [10,20,30]
            0xD2, 1, 12, 10, 0, 0, 0, 20, 0, 0, 0, 30, 0, 0, 0,

            // ri64 = [-2,0,2] = [0xFFFFFFFFFFFFFFFE,0,2] = [x01 x7F x7F x7F x7F x7F x7F x7F x7F x7E, 0, 2]
            0xDA, 1, 12, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0, 2,

            // rsf64 = [-100, 0, 100] = [0xFFFFFFFFFFFFFF9C, 0, 100]
            0xE2, 1, 24, 0x9C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0,

            // rs64 = [-20,0,20] = [39,0,40]
            0xEA, 1, 3, 39, 0, 40,

            // ru64 = [3,4,5]
            0x92, 0xD, 3, 3, 4, 5,

            // rf64 = [30,40,50]
            0x9A, 0xD, 24, 30, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0,

            // rf = [3.5] = [0x40600000]
            0xA2, 0xD, 4, 0, 0, 0x60, 0x40,

            // rd = [1.1,2.2,3.3] = [0x3FF1 9999 9999 999A, 0x4001 9999 9999 999A, 0x400A 6666 6666 6666]
            0xAA, 0xD, 24,
            0x9A, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF1, 0x3F,
            0x9A, 0x99, 0x99, 0x99, 0x99, 0x99, 0x01, 0x40,
            0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0A, 0x40,

            // rby = ["defgh", "abcde"] = [x64 x65 x66 x67 x68, x61 x62 x63 x64 x65]
            0xB2, 0xD, 5, 0x64, 0x65, 0x66, 0x67, 0x68,
            0xB2, 0xD, 5, 0x61, 0x62, 0x63, 0x64, 0x65,

            // rstr = ["ghikj","lmnop"] = [x67 x68 x69 x6b x6a, x6c x6d x6e x6f x70]
            0xBA, 0xD, 5, 0x67, 0x68, 0x69, 0x6B, 0x6A,
            0xBA, 0xD, 5, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,

            // ren = [ENUM_C,ENUM_B,ENUM_A] = [2,1,0]
            0xC2, 0xD, 3, 2, 1, 0,

            // rmsg = [{b = true},{u64 = 10234},{}]; 10234 = 0x27FA = 0x4F,0x7A
            0xCA, 0xD, 2, 0x8, 1,
            0xCA, 0xD, 3, 0x50, 0xFA, 0x4F,
            0xCA, 0xD, 0,

            // rpod = [{u = 1},{i = -1}]
            0xD2, 0xD, 2, 0x8, 1,
            0xD2, 0xD, 2, 0x10, 1,
        ]).buffer;

        function expect(a, b) {
            console.assert(a == b, a, b);
        }

        function isEmpty(a) {
            for (var prop in a) {
                return false;
            }
            return true;
        }

        function test_message(m) {
            expect(true, m.b);
            expect(-23, m.i32);
            expect(-1234, m.s32);
            expect(-34757, m.sf32);
            expect(1, m.u32);
            expect(34757, m.f32);
            expect("-3434565678781212898", m.i64);
            expect("-1234567890123456789", m.sf64);
            expect("-23585", m.s64);
            expect("10234", m.u64);
            expect("1234567890123456789", m.f64);
            expect(314, m.f);
            expect(3.141, m.d);
            expect(5, m.by.byteLength);
            expect("abcde", proto.utf8to16(m.by, 0, 5));
            expect("abc$¢€𝌆", m.str);
            expect(3, m.rb.length);
            expect(false, m.rb[0]);
            expect(true, m.rb[1]);
            expect(false, m.rb[2]);
            expect(3, m.ru32.length);
            expect(1, m.ru32[0]);
            expect(2, m.ru32[1]);
            expect(3, m.ru32[2]);
            expect(3, m.ru64.length);
            expect(3, m.ru64[0]);
            expect(4, m.ru64[1]);
            expect(5, m.ru64[2]);
            expect(3, m.ri32.length);
            expect(-1, m.ri32[0]);
            expect(0, m.ri32[1]);
            expect(1, m.ri32[2]);
            expect(3, m.ri64.length);
            expect(-2, m.ri64[0]);
            expect(0, m.ri64[1]);
            expect(2, m.ri64[2]);
            expect(3, m.rs32.length);
            expect(-10, m.rs32[0]);
            expect(0, m.rs32[1]);
            expect(10, m.rs32[2]);
            expect(3, m.rs64.length);
            expect(-20, m.rs64[0]);
            expect(0, m.rs64[1]);
            expect(20, m.rs64[2]);
            expect(3, m.rf32.length);
            expect(10, m.rf32[0]);
            expect(20, m.rf32[1]);
            expect(30, m.rf32[2]);
            expect(3, m.rf64.length);
            expect(30, m.rf64[0]);
            expect(40, m.rf64[1]);
            expect(50, m.rf64[2]);
            expect(3, m.rsf32.length);
            expect(-10, m.rsf32[0]);
            expect(20, m.rsf32[1]);
            expect(0, m.rsf32[2]);
            expect(3, m.rsf64.length);
            expect(-100, m.rsf64[0]);
            expect(0, m.rsf64[1]);
            expect(100, m.rsf64[2]);
            expect(1, m.rf.length);
            expect(3.5, m.rf[0]);
            expect(3, m.rd.length);
            expect(1.1, m.rd[0]);
            expect(2.2, m.rd[1]);
            expect(3.3, m.rd[2]);
            expect(2, m.rby.length);
            expect(5, m.rby[0].byteLength);
            expect("defgh", proto.utf8to16(m.rby[0], 0, 5));
            expect(5, m.rby[1].byteLength);
            expect("abcde", proto.utf8to16(m.rby[1], 0, 5));
            expect(2, m.rstr.length);
            expect("ghikj", m.rstr[0]);
            expect("lmnop", m.rstr[1]);
            expect(3, m.ren.length);
            expect("ENUM_C", m.ren[0]);
            expect("ENUM_B", m.ren[1]);
            expect("ENUM_A", m.ren[2]);
            expect(true, m.msg.b);
            expect(-12, m.pod.i);
            expect(3, m.rmsg.length);
            expect(true, m.rmsg[0].b);
            expect(10234, m.rmsg[1].u64);
            expect(true, isEmpty(m.rmsg[2]));
            expect(2, m.rpod.length);
            expect(1, m.rpod[0].u);
            expect(-1, m.rpod[1].i);
        }

        var decoded = proto.decode(proto.types.com.example.TestMessage, test_proto);
        console.log(decoded);
        test_message(decoded);

    </script>
</head>

<body>
    Hello World!
</body>

</html>