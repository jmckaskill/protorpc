<html>

<head>
    <script>


        // flags
        // bits 0-3 - base type
        // bit 4 - repeated
        // bit 5 - has extra decoder
        // 0/16 - bool
        // 1/17 - uint32
        // 2/18 - int32
        // 3/19 - sint32
        // 36/52 - enum
        // 5/21 - uint64
        // 6/22 - int64
        // 7/23 - sint64
        // 8/24 - fixed32
        // 9/25 - sfixed32
        // 10/26 - fixed64
        // 11/27 - sfixed64
        // 12/28 - float
        // 13/29 - double
        // 14/30 - string
        // 15/31/47/63 - bytes & msg

        var proto = (function () {
            // in these functions
            // v is a Uint8Array pointing to the original input buffer
            // r is an array of [current offset, current end]
            var get_varint = function (v, r) {
                var shift = 0;
                var ret = 0;
                while (r[0] < r[1]) {
                    var u = v.getUint8(r[0]);
                    ret |= (u & 0x7F) << shift;
                    r[0]++;
                    if ((u & 0x80) == 0) {
                        return ret >>> 0;
                    }
                    shift += 7;
                }
                throw new Error("invalid protobuf");
            };
            var get_varint_64 = function (v, r) {
                var shift = 0;
                var low = 0;
                var high = 0;
                while (r[0] < r[1]) {
                    var u = v.getUint8(r[0]);
                    var w = u & 0x7F;
                    if (shift > 32) {
                        high |= w << (shift - 32);
                    } else if (shift) {
                        low |= w << shift;
                        high |= w >>> (32 - shift);
                    } else {
                        low = w;
                    }
                    r[0]++;
                    if ((u & 0x80) == 0) {
                        return [low >>> 0, high >>> 0];
                    }
                    shift += 7;
                }
                throw new Error("invalid protobuf");
            };
            var skip = function (v, r, tag) {
                switch (tag & 7) {
                    case 0: // varint
                        while (r[0] < r[1] && (v.getUint8(r[0]) & 0x80)) {
                            r[0]++;
                        }
                        r[0]++;
                        break;
                    case 1: // fixed 64
                        r[0] += 8;
                        break;
                    case 2: // variable
                        r[0] += get_varint(v, r);
                        break;
                    case 5: // fixed 32
                        r[0] += 4;
                        break;
                }
                if (r[0] > r[1]) {
                    throw new Error("invalid protobuf");
                }
            };
            var get_varlen = function (v, r) {
                var len = get_varint(v, r);
                var ret = [r[0], r[0] + len];
                r[0] += len;
                return ret;
            };
            var utf8len = function (str) {
                var ret = 0;
                var len = str.length;
                for (var i = 0; i < len; i++) {
                    var ch = str.charCodeAt(i);
                    if (ch < 0x80) {
                        ret += 1;
                    } else if (ch < 0x800) {
                        ret += 2;
                    } else if ((ch & 0xFF00) == 0xD800) {
                        ret += 4;
                        i++;
                    } else {
                        ret += 3;
                    }
                }
                return ret;
            };
            var encode_utf8 = function (v, idx, str) {
                var len = str.length;
                for (var i = 0; i < len; i++) {
                    var ch = str.charCodeAt(i);
                    if (ch < 0x80) {
                        // 0xxxxxxx
                        v.setUint8(idx++, ch);
                    } else if (ch < 0x800) {
                        // 110x xxxx   10xx xxxx
                        v.setUint8(idx++, 0xC0 | (ch >>> 6));
                        v.setUint8(idx++, 0x80 | (ch & 0x3F));
                    } else if ((ch & 0xFF00) == 0xD800) {
                        // high surrogate 1101 10xx xxxx xxxx 
                        // low surrogate 1101 11xx xxxx xxxx
                        var high = ch & 0x3FF;
                        var low = str.charCodeAt(++i) & 0x3FF;
                        // decode to unicode code point first
                        // UTF16 is shifted by 0x10000
                        var u = ((high << 10) | low) + 0x10000;
                        // then encode to utf-8
                        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
                        v.setUint8(idx++, 0xF0 | (u >>> 18));
                        v.setUint8(idx++, 0x80 | ((u >>> 12) & 0x3F));
                        v.setUint8(idx++, 0x80 | ((u >>> 6) & 0x3F));
                        v.setUint8(idx++, 0x80 | (u & 0x3F));
                    } else {
                        // 1110 xxxx  10xx xxxx  10xx xxxx
                        v.setUint8(idx++, 0xE0 | (ch >>> 12));
                        v.setUint8(idx++, 0x80 | ((ch >>> 6) & 0x3F));
                        v.setUint8(idx++, 0x80 | (ch & 0x3F));
                    }
                }
                return idx;
            }
            var utf8to16 = function (v, i, end) {
                var out = "";
                while (i < end) {
                    var c = v.getUint8(i++);
                    switch (c >> 4) {
                        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
                            // 0xxxxxxx
                            out += String.fromCharCode(c);
                            break;
                        case 12: case 13:
                            // 110x xxxx   10xx xxxx
                            var c2 = v.getUint8(i++);
                            out += String.fromCharCode(((c & 0x1F) << 6) | (c2 & 0x3F));
                            break;
                        case 14:
                            // 1110 xxxx  10xx xxxx  10xx xxxx
                            var c2 = v.getUint8(i++);
                            var c3 = v.getUint8(i++);
                            out += String.fromCharCode(((c & 0x0F) << 12) |
                                ((c2 & 0x3F) << 6) |
                                ((c3 & 0x3F) << 0));
                            break;
                        case 15:
                            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
                            // decode to unicode code point first
                            var c2 = v.getUint8(i++);
                            var c3 = v.getUint8(i++);
                            var c4 = v.getUint8(i++);
                            var u = ((c & 7) << 18) | ((c2 & 0x3F) << 12) | ((c3 & 0x3F) << 6) | (c4 & 0x3F);
                            // then encode to UTF-16
                            // UTF16 is shifted by 0x10000
                            u -= 0x10000;
                            // high surrogate 1101 10xx xxxx xxxx 
                            var high = 0xD800 | (u >> 10);
                            // low surrogate 1101 11xx xxxx xxxx
                            var low = 0xDC00 | (u & 0x3FF);
                            out += String.fromCharCode(high, low);
                            break;
                    }
                }
                return out;
            }
            var decode_u64 = function (low, high) {
                var rem = [];
                while (high) {
                    var rh = high % 10;
                    var qh = Math.floor(high / 10);
                    var xl = low + (rh * 4294967296);
                    var rl = xl % 10;
                    var ql = Math.floor(xl / 10);
                    rem.push(rl + 48 /*'0'*/);
                    low = ql;
                    high = qh;
                }
                while (low) {
                    var r = low % 10;
                    var q = Math.floor(low / 10);
                    rem.push(r + 48 /*'0'*/);
                    low = q;
                }
                rem.reverse();
                if (!rem.length) {
                    rem.push(48);
                }
                return String.fromCharCode.apply(null, rem);
            }
            var decode_i64 = function (low, high) {
                if (high >= 0x80000000) {
                    return "-" + decode_u64((0xFFFFFFFF - low) + 1, 0xFFFFFFFF - high);
                } else {
                    return decode_u64(low, high);
                }
            }
            var encode_u64 = function (str, off) {
                var low = 0.0;
                var high = 0;
                for (var i = off; i < str.length; i++) {
                    low *= 10;
                    high *= 10;
                    var q = Math.floor(low / 4294967296);
                    low -= q * 4294967296;
                    high += q;
                    var ch = str.charCodeAt(i);
                    if (ch < 48 /*0*/ || ch > 57 /*9*/) {
                        throw new Error("invalid 64 bit integer string");
                    }
                    low += ch - 48 /*'0'*/;
                }
                return [low, high];
            };
            var encode_i64 = function (str) {
                if (str.charAt(0) == "-") {
                    var lh = encode_u64(str, 1);
                    lh[0] = 0xFFFFFFFF - (lh[0] - 1);
                    lh[1] = 0xFFFFFFFF - lh[1];
                    return lh;
                } else {
                    return encode_u64(str, 0);
                }
            };
            var decode_message;
            var decode_field = function (v, r, type, extra) {
                switch (type) {
                    case 0: // bool
                        return get_varint(v, r) != 0;
                    case 1: // uint32
                        return get_varint(v, r);
                    case 2: // int32
                        return get_varint(v, r) >> 0;
                    case 3: // sint32
                        // 0 -> 0, 1 -> -1, 2 -> 1, 3 -> -2
                        var u = get_varint(v, r);
                        return (u >>> 1) ^ -((u & 1) >> 0);
                    case 4: // enum
                        var u = get_varint(v, r);
                        return extra[u];
                    case 5: // uint64
                        var lh = get_varint_64(v, r);
                        return decode_u64(lh[0], lh[1]);
                    case 6: // int64
                        var lh = get_varint_64(v, r);
                        return decode_i64(lh[0], lh[1]);
                    case 7: // sint64
                        var lh = get_varint_64(v, r);
                        // equivalent to (u >> 1) ^ -(int64_t)(u & 1)
                        var low = lh[0];
                        var high = lh[1];
                        var mask = -(low & 1);
                        low = (((low >>> 1) | (high << 31)) ^ mask) >>> 0;
                        high = ((high >>> 1) ^ mask) >>> 0;
                        return decode_i64(low, high);
                    case 8: // fixed32
                        var ret = v.getUint32(r[0], true);
                        r[0] += 4;
                        return ret;
                    case 9: // sfixed32
                        var ret = v.getInt32(r[0], true);
                        r[0] += 4;
                        return ret;
                    case 10: // fixed64
                        var low = v.getUint32(r[0], true);
                        var high = v.getUint32(r[0] + 4, true);
                        r[0] += 8;
                        return decode_u64(low, high);
                    case 11: // sfixed64
                        var low = v.getUint32(r[0], true);
                        var high = v.getUint32(r[0] + 4, true);
                        r[0] += 8;
                        return decode_i64(low, high);
                    case 12: // float
                        var ret = v.getFloat32(r[0], true);;
                        r[0] += 4;
                        return ret;
                    case 13: // double
                        var ret = v.getFloat64(r[0], true);
                        r[0] += 8;
                        return ret;
                    case 14: // string
                        var rs = get_varlen(v, r);
                        return utf8to16(v, rs[0], rs[1]);
                    case 15: // bytes
                        var rs = get_varlen(v, r);
                        if (extra) {
                            return decode_message(extra, v, rs);
                        } else {
                            return v.buffer.slice(rs[0], rs[1]);
                        }
                }
            }
            var decode_packed = function (v, r, type, extra) {
                var rs = get_varlen(v, r);
                var ret = [];
                while (rs[0] < rs[1]) {
                    ret.push(decode_field(v, rs, type, extra));
                }
                return ret;
            };
            var decode_repeated = function (v, r, tag, type, extra) {
                var ret = [];
                for (; ;) {
                    ret.push(decode_field(v, r, type, extra));
                    var undo = r[0];
                    if (r[0] >= r[1] || get_varint(v, r) != tag) {
                        r[0] = undo;
                        return ret;
                    }
                }
            };
            decode_message = function (fields, v, r) {
                var ret = {};
                var fidx = 0;
                var off = 0;
                while (r[0] < r[1] && fidx < fields.length) {
                    var want = fields[fidx++];
                    var type = fields[fidx++];
                    var undo = r[0];
                    var have = get_varint(v, r);
                    if (want < have) {
                        r[0] = undo;
                        fidx += (type & 32) ? 2 : 1;
                        continue;
                    } else if (have < want) {
                        skip(v, r, have);
                        continue;
                    }

                    var name = fields[fidx++];
                    var extra = (type & 32) ? fields[fidx++] : null;
                    var base = type & 15;

                    if ((type & 16) == 0) {
                        ret[name] = decode_field(v, r, base, extra);
                    } else if (base <= 13) {
                        ret[name] = decode_packed(v, r, base, extra);
                    } else {
                        ret[name] = decode_repeated(v, r, have, base, extra);
                    }
                }
                return ret;
            };
            var enum_decoder = function (enc) {
                var dec = {};
                for (var i in enc) {
                    var name = enc[i];
                    dec[name] = parseInt(i);
                }
                enc._decoder = dec;
                return dec;
            };
            var encode_varint = function (v, idx, val) {
                while (val >= 0x80) {
                    v.setUint8(idx++, 0x80 | (val & 0x7F));
                    val >>>= 7;
                }
                v.setUint8(idx++, val);
                return idx;
            };
            var encode_varint_64 = function (v, idx, low, high) {
                while (high || low >= 0x80) {
                    v.setUint8(idx++, 0x80 | (low & 0x7F));
                    low = (low >>> 7) | (high << 25);
                    high >>>= 7;
                }
                v.setUint8(idx++, low);
                return idx;
            };
            var varint_length = function (val) {
                if (val < 0x80) {
                    return 1;
                } else if (val < 0x4000) {
                    return 2;
                } else if (val < 0x200000) {
                    return 3;
                } else if (val < 0x10000000) {
                    return 4;
                } else {
                    return 5;
                }
            };
            var varint_length_64 = function (low, high) {
                if (!high) {
                    return varint_length(low);
                } else {
                    // we have at least 32 bits
                    high >>>= 3;
                    ret = 5;
                    while (high) {
                        ret += 1;
                        high >>>= 7;
                    }
                    return ret;
                }
            };
            var message_length;
            var encode_message;
            var field_length = function (val, type, extra, save) {
                switch (type) {
                    case 0: // bool
                        return 1;
                    case 1: // uint32
                        return varint_length(val);
                    case 2: // int32
                        return varint_length(val >>> 0);
                    case 3: // sint32
                        var u = (val << 1) ^ (val >> 31);
                        return varint_length(u);
                    case 4: // enum
                        var dec = extra._decoder || enum_decoder(extra);
                        var u = dec[val];
                        return varint_length(u);
                    case 5: // uint64
                        var lh = encode_u64(val, 0);
                        var low = lh[0];
                        var high = lh[1];
                        save.push(low);
                        save.push(high);
                        return varint_length_64(low, high);
                    case 6: // int64
                        var lh = encode_i64(val);
                        var low = lh[0];
                        var high = lh[1];
                        save.push(low);
                        save.push(high);
                        return varint_length_64(low, high);
                    case 7: // sint64
                        var lh = encode_i64(val);
                        // equivalent to ((uint64_t)i << 1) ^ (uint64_t)(i >> 63)
                        var low = lh[0];
                        var high = lh[1];
                        var mask = high >> 31;
                        high = ((high << 1) | (low >>> 31)) ^ mask;
                        low = (low << 1) ^ mask
                        save.push(low);
                        save.push(high);
                        return varint_length_64(low, high);
                    case 8: // fixed32
                    case 9: // sfixed32
                    case 12: // float
                        return 4;
                    case 10: // fixed64
                    case 11: // sfixed64
                    case 13: // double
                        return 8;
                    case 14: // string
                        var u8len = utf8len(val);
                        save.push(u8len);
                        return varint_length(u8len) + u8len;
                    case 15: // bytes/messages
                        var len;
                        if (extra) {
                            var savei = save.length;
                            save.push(0);
                            len = message_length(extra, val, save);
                            save[savei] = len;
                        } else {
                            len = val.byteLength;
                        }
                        return varint_length(len) + len;
                }
            };
            var encode_field = function (v, idx, val, type, extra, save) {
                switch (type) {
                    case 0: // bool
                        v.setUint8(idx, val ? 1 : 0);
                        return idx + 1;
                    case 1: // uint32
                        return encode_varint(v, idx, val);
                    case 2: // int32
                        return encode_varint(v, idx, val >>> 0);
                    case 3: // sint32
                        var u = (val << 1) ^ (val >> 31);
                        return encode_varint(v, idx, u);
                    case 4: // enum
                        var dec = extra._decoder;
                        var u = dec[val];
                        return encode_varint(v, idx, u);
                    case 5: // uint64
                    case 6: // int64
                    case 7: // sint64
                        var low = save[save[0]++];
                        var high = save[save[0]++];
                        return encode_varint_64(v, idx, low, high);
                    case 8: // fixed32
                        v.setUint32(idx, val, true);
                        return idx + 4;
                    case 9: // sfixed32
                        v.setInt32(idx, val, true);
                        return idx + 4;
                    case 12: // float
                        v.setFloat32(idx, val, true);
                        return idx + 4;
                    case 10: // fixed64
                        var lh = encode_u64(val, 0);
                        v.setUint32(idx, lh[0], true);
                        v.setUint32(idx + 4, lh[1], true);
                        return idx + 8;
                    case 11: // sfixed64
                        var lh = encode_i64(val, 0);
                        v.setUint32(idx, lh[0], true);
                        v.setUint32(idx + 4, lh[1], true);
                        return idx + 8;
                    case 13: // double
                        v.setFloat64(idx, val, true);
                        return idx + 8;
                    case 14: // string
                        var u8len = save[save[0]++];
                        idx = encode_varint(v, idx, u8len);
                        return encode_utf8(v, idx, val);
                    case 15: // bytes/messages
                        if (extra) {
                            var len = save[save[0]++];
                            idx = encode_varint(v, idx, len);
                            return encode_message(v, idx, val, extra, save);
                        } else {
                            var len = val.byteLength;
                            var src = new DataView(val);
                            idx = encode_varint(v, idx, len);
                            for (var i = 0; i < len; i++) {
                                v.setUint8(idx + i, src.getUint8(i));
                            }
                            return idx + len;
                        }
                }
            };
            var packed_length = function (val, type, extra, save) {
                var elen = 0;
                var slen = val.length;
                var savei = save.length;
                save.push(0);
                for (var i = 0; i < slen; i++) {
                    elen += field_length(val[i], type, extra, save);
                }
                save[savei] = elen;
                return varint_length(elen) + elen;
            };
            var encode_packed = function (v, idx, val, type, extra, save) {
                var elen = save[save[0]++];
                var slen = val.length;
                idx = encode_varint(v, idx, elen);
                for (var i = 0; i < slen; i++) {
                    idx = encode_field(v, idx, val[i], type, extra, save);
                }
                return idx;
            };
            var repeated_length = function (val, taglen, type, extra, save) {
                var ret = 0;
                for (var i = 0; i < val.length; i++) {
                    ret += taglen + field_length(val[i], type, extra, save);
                }
                return ret;
            };
            var encode_repeated = function (v, idx, val, tag, type, extra, save) {
                var slen = val.length;
                for (var i = 0; i < slen; i++) {
                    idx = encode_varint(v, idx, tag);
                    idx = encode_field(v, idx, val[i], type, extra, save);
                }
                return idx;
            };
            message_length = function (fields, m, save) {
                var fidx = 0;
                var ret = 0;
                while (fidx < fields.length) {
                    var tag = fields[fidx++];
                    var type = fields[fidx++];
                    var name = fields[fidx++];
                    var extra = (type & 32) ? fields[fidx++] : null;
                    var val = m[name];

                    if (!val) {
                        continue;
                    }

                    var base = type & 15;
                    var taglen = varint_length(tag);
                    if ((type & 16) == 0) {
                        ret += taglen + field_length(val, base, extra, save);
                    } else if (val.length) {
                        if (base <= 13) {
                            ret += taglen + packed_length(val, base, extra, save);
                        } else {
                            ret += repeated_length(val, taglen, base, extra, save);
                        }
                    }
                }
                return ret;
            };
            encode_message = function (v, idx, m, fields, save) {
                var fidx = 0;
                while (fidx < fields.length) {
                    var tag = fields[fidx++];
                    var type = fields[fidx++];
                    var name = fields[fidx++];
                    var extra = (type & 32) ? fields[fidx++] : null;
                    var val = m[name];

                    if (!val) {
                        continue;
                    }

                    var base = type & 15;
                    if ((type & 16) == 0) {
                        idx = encode_varint(v, idx, tag);
                        idx = encode_field(v, idx, val, base, extra, save);
                    } else if (val.length) {
                        if (base <= 13) {
                            idx = encode_varint(v, idx, tag);
                            idx = encode_packed(v, idx, val, base, extra, save);
                        } else {
                            idx = encode_repeated(v, idx, val, tag, base, extra, save);
                        }
                    }
                }
                return idx;
            };
            var types = {};
            var add_types = function (pkgstr, msgs, enums) {
                // setup series of objects so that proto.types.com.example.TestMessage works
                var pkg = types;
                var parts = pkgstr.split(".");
                for (var i in parts) {
                    var part = parts[i];
                    var child = pkg[part];
                    if (!child) {
                        child = {};
                        pkg[part] = child;
                    }
                    pkg = child;
                }
                for (var name in msgs) {
                    pkg[name] = msgs[name];
                }
                for (var name in enums) {
                    pkg[name] = enums[name];
                }
            };
            return {
                decode: function (fields, buf) {
                    if (buf.buffer) {
                        // buf is a typed view or data view
                        return decode_message(fields, new DataView(buf.buffer), [buf.byteOffset, buf.byteOffset + buf.byteLength]);
                    } else {
                        // buf is an array buffer
                        return decode_message(fields, new DataView(buf), [0, buf.byteLength]);
                    }
                },
                encode: function (fields, m) {
                    var save = [1]; // save[0] is the index used by encode_*
                    var len = message_length(fields, m, save);
                    var ab = new ArrayBuffer(len);
                    encode_message(new DataView(ab), 0, m, fields, save);
                    return ab;
                },
                add: add_types,
                types: types,
                utf8to16: utf8to16,
            };
        })();

        (function (proto) {
            var TestEnum = {
                [0]: "ENUM_A",
                [1]: "ENUM_B",
                [2]: "ENUM_C",
            };
            var TestPod = [
                8, 1, "u",
                16, 3, "i",
            ];
            var TestMessage = [
                8, 0, "b",    // 2
                16, 2, "i32",  // 5
                24, 3, "s32",  // 8
                37, 9, "sf32", // 11
                40, 1, "u32",  // 14
                53, 8, "f32",  // 17
                56, 6, "i64",  // 20
                65, 11, "sf64", // 23
                72, 7, "s64",  // 26
                80, 5, "u64",  // 29
                89, 10, "f64",  // 32
                101, 12, "f",   // 35
                105, 13, "d",   // 38
                114, 15, "by", // 41
                122, 14, "str",// 44
                128, 36, "en", TestEnum, // 48
                138, 47, "msg", null, // 52
                146, 47, "pod", TestPod, // 56
                170, 16, "rb", // 59
                178, 18, "ri32", // 62
                186, 19, "rs32", // 65
                194, 25, "rsf32", // 68
                202, 17, "ru32", // 71
                210, 24, "rf32", // 74
                218, 22, "ri64", // 77
                226, 27, "rsf64", // 80
                234, 23, "rs64", // 83
                1682, 21, "ru64", // 86
                1690, 26, "rf64", // 89
                1698, 28, "rf", // 92
                1706, 29, "rd", // 95
                1714, 31, "rby", // 98
                1722, 30, "rstr", // 101
                1730, 52, "ren", TestEnum, // 105
                1738, 63, "rmsg", null, // 109
                1746, 63, "rpod", TestPod, // 113
            ];
            TestMessage[52] = TestMessage;
            TestMessage[109] = TestMessage;
            var msgs = { TestMessage: TestMessage, TestPod: TestPod };
            var enums = { TestEnum: TestEnum };
            proto.add("com.example", msgs, enums);
        })(proto);

        var test_proto = new Uint8Array([
            // b = true
            0x08, 1,

            // i32 = -23 = 0xFFFFFFE9 = xF,x7F,x7F,x7F,x69
            0x10, 0xE9, 0xFF, 0xFF, 0xFF, 0xF,

            // s32 = -1234 = 2467 = 0x9A3 = 0x13,0x23
            0x18, 0xA3, 0x13,

            // sf32 = -34757 = 0xFFFF783B
            0x25, 0x3B, 0x78, 0xFF, 0xFF,

            // u32 = 1
            0x28, 1,

            // f32 = 34757 = 0x000087C5
            0x35, 0xC5, 0x87, 0, 0,

            // i64 = -3434565678781212898 = 0xD055F8B6567F571E = 1E 2E 7D 33 65 16 7E 2A 50 01
            0x38, 0x9E, 0xAE, 0xFD, 0xB3, 0xE5, 0x96, 0xFE, 0xAA, 0xD0, 0x01,
            //34
            // sf64 = -1234567890123456789 = 0x EEDD EF0B 8216 7EEB
            0x41, 0xEB, 0x7E, 0x16, 0x82, 0x0B, 0xEF, 0xDD, 0xEE,

            // s64 = -23585 = 47169 = xB841 = x02,x70,x41
            0x48, 0xC1, 0xF0, 0x02,

            // u64 = 10234 = 0x27FA = 0x4F,0x7A
            0x50, 0xFA, 0x4F,
            //50
            // f64 = 1234567890123456789 = 0x 1122 10F4 7DE9 8115
            0x59, 0x15, 0x81, 0xE9, 0x7D, 0xF4, 0x10, 0x22, 0x11,

            // f = 314 = 0x439d0000
            0x65, 0, 0, 0x9D, 0x43,

            // d = 3.141 = 0x4009 20C4 9BA5 E354
            0x69, 0x54, 0xE3, 0xA5, 0x9B, 0xC4, 0x20, 0x09, 0x40,
            //73
            // by = "abcde" = x61 x62 x63 x64 x65
            0x72, 5, 0x61, 0x62, 0x63, 0x64, 0x65,

            // str = "abc$Â¢â‚¬ðŒ†" = x61 x62 x63 x24 xC2A2 xE282AC xF09D8C86
            0x7A, 13, 0x61, 0x62, 0x63, 0x24, 0xC2, 0xA2, 0xE2, 0x82, 0xAC, 0xF0, 0x9D, 0x8C, 0x86,
            //95
            // en = ENUM_C = 2
            0x80, 1, 2,

            // msg = {b = true}
            0x8A, 1, 2, 0x8, 1,
            //103
            // pod = {i = -12}, -12 zigzag = 23
            0x92, 1, 2, 0x10, 23,
            //108
            // rb = [false,true,false]
            0xAA, 1, 3, 0, 1, 0,
            //114
            // ri32 = [-1,0,1] = [0xFFFFFFFF,0,1] = [xF x7F x7F x7F x7F, 0, 1]
            0xB2, 1, 7, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0, 1,
            //124
            // rs32 = [-10,0,10] = [19,0,20]
            0xBA, 1, 3, 19, 0, 20,
            //130
            // rsf32 = [-10,20,0] = [0xFFFFFFF6,20,0]
            0xC2, 1, 12, 0xF6, 0xFF, 0xFF, 0xFF, 20, 0, 0, 0, 0, 0, 0, 0,
            //145
            // ru32 = [1,2,3]
            0xCA, 1, 3, 1, 2, 3,
            //151
            // rf32 = [10,20,30]
            0xD2, 1, 12, 10, 0, 0, 0, 20, 0, 0, 0, 30, 0, 0, 0,

            // ri64 = [-2,0,2] = [0xFFFFFFFFFFFFFFFE,0,2] = [x01 x7F x7F x7F x7F x7F x7F x7F x7F x7E, 0, 2]
            0xDA, 1, 12, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0, 2,

            // rsf64 = [-100, 0, 100] = [0xFFFFFFFFFFFFFF9C, 0, 100]
            0xE2, 1, 24, 0x9C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0,

            // rs64 = [-20,0,20] = [39,0,40]
            0xEA, 1, 3, 39, 0, 40,

            // ru64 = [3,4,5]
            0x92, 0xD, 3, 3, 4, 5,

            // rf64 = [30,40,50]
            0x9A, 0xD, 24, 30, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0,

            // rf = [3.5] = [0x40600000]
            0xA2, 0xD, 4, 0, 0, 0x60, 0x40,

            // rd = [1.1,2.2,3.3] = [0x3FF1 9999 9999 999A, 0x4001 9999 9999 999A, 0x400A 6666 6666 6666]
            0xAA, 0xD, 24,
            0x9A, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF1, 0x3F,
            0x9A, 0x99, 0x99, 0x99, 0x99, 0x99, 0x01, 0x40,
            0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0A, 0x40,

            // rby = ["defgh", "abcde"] = [x64 x65 x66 x67 x68, x61 x62 x63 x64 x65]
            0xB2, 0xD, 5, 0x64, 0x65, 0x66, 0x67, 0x68,
            0xB2, 0xD, 5, 0x61, 0x62, 0x63, 0x64, 0x65,

            // rstr = ["ghikj","lmnop"] = [x67 x68 x69 x6b x6a, x6c x6d x6e x6f x70]
            0xBA, 0xD, 5, 0x67, 0x68, 0x69, 0x6B, 0x6A,
            0xBA, 0xD, 5, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,

            // ren = [ENUM_C,ENUM_B,ENUM_A] = [2,1,0]
            0xC2, 0xD, 3, 2, 1, 0,

            // rmsg = [{b = true},{u64 = 10234},{}]; 10234 = 0x27FA = 0x4F,0x7A
            0xCA, 0xD, 2, 0x8, 1,
            0xCA, 0xD, 3, 0x50, 0xFA, 0x4F,
            0xCA, 0xD, 0,

            // rpod = [{u = 1},{i = -1}]
            0xD2, 0xD, 2, 0x8, 1,
            0xD2, 0xD, 2, 0x10, 1,
        ]).buffer;

        function expect(a, b) {
            console.assert(a == b, a, b);
        }

        function isEmpty(a) {
            for (var prop in a) {
                return false;
            }
            return true;
        }

        function test_message(m) {
            expect(true, m.b);
            expect(-23, m.i32);
            expect(-1234, m.s32);
            expect(-34757, m.sf32);
            expect(1, m.u32);
            expect(34757, m.f32);
            expect("-3434565678781212898", m.i64);
            expect("-1234567890123456789", m.sf64);
            expect("-23585", m.s64);
            expect("10234", m.u64);
            expect("1234567890123456789", m.f64);
            expect(314, m.f);
            expect(3.141, m.d);
            expect(5, m.by.byteLength);
            expect("abcde", proto.utf8to16(new DataView(m.by), 0, 5));
            expect("abc$Â¢â‚¬ðŒ†", m.str);
            expect(3, m.rb.length);
            expect(false, m.rb[0]);
            expect(true, m.rb[1]);
            expect(false, m.rb[2]);
            expect(3, m.ru32.length);
            expect(1, m.ru32[0]);
            expect(2, m.ru32[1]);
            expect(3, m.ru32[2]);
            expect(3, m.ru64.length);
            expect(3, m.ru64[0]);
            expect(4, m.ru64[1]);
            expect(5, m.ru64[2]);
            expect(3, m.ri32.length);
            expect(-1, m.ri32[0]);
            expect(0, m.ri32[1]);
            expect(1, m.ri32[2]);
            expect(3, m.ri64.length);
            expect(-2, m.ri64[0]);
            expect(0, m.ri64[1]);
            expect(2, m.ri64[2]);
            expect(3, m.rs32.length);
            expect(-10, m.rs32[0]);
            expect(0, m.rs32[1]);
            expect(10, m.rs32[2]);
            expect(3, m.rs64.length);
            expect(-20, m.rs64[0]);
            expect(0, m.rs64[1]);
            expect(20, m.rs64[2]);
            expect(3, m.rf32.length);
            expect(10, m.rf32[0]);
            expect(20, m.rf32[1]);
            expect(30, m.rf32[2]);
            expect(3, m.rf64.length);
            expect(30, m.rf64[0]);
            expect(40, m.rf64[1]);
            expect(50, m.rf64[2]);
            expect(3, m.rsf32.length);
            expect(-10, m.rsf32[0]);
            expect(20, m.rsf32[1]);
            expect(0, m.rsf32[2]);
            expect(3, m.rsf64.length);
            expect(-100, m.rsf64[0]);
            expect(0, m.rsf64[1]);
            expect(100, m.rsf64[2]);
            expect(1, m.rf.length);
            expect(3.5, m.rf[0]);
            expect(3, m.rd.length);
            expect(1.1, m.rd[0]);
            expect(2.2, m.rd[1]);
            expect(3.3, m.rd[2]);
            expect(2, m.rby.length);
            expect(5, m.rby[0].byteLength);
            expect("defgh", proto.utf8to16(new DataView(m.rby[0]), 0, 5));
            expect(5, m.rby[1].byteLength);
            expect("abcde", proto.utf8to16(new DataView(m.rby[1]), 0, 5));
            expect(2, m.rstr.length);
            expect("ghikj", m.rstr[0]);
            expect("lmnop", m.rstr[1]);
            expect(3, m.ren.length);
            expect("ENUM_C", m.ren[0]);
            expect("ENUM_B", m.ren[1]);
            expect("ENUM_A", m.ren[2]);
            expect(true, m.msg.b);
            expect(-12, m.pod.i);
            expect(3, m.rmsg.length);
            expect(true, m.rmsg[0].b);
            expect(10234, m.rmsg[1].u64);
            expect(true, isEmpty(m.rmsg[2]));
            expect(2, m.rpod.length);
            expect(1, m.rpod[0].u);
            expect(-1, m.rpod[1].i);
        }

        var decoded = proto.decode(proto.types.com.example.TestMessage, test_proto);
        console.log(decoded);
        test_message(decoded);
        var encoded = proto.encode(proto.types.com.example.TestMessage, decoded);
        expect(encoded.byteLength, test_proto.byteLength);
        for (var i = 0; i < encoded.byteLength; i++) {
            //console.log("check byte ", i);
            expect(new DataView(encoded).getUint8(i), new DataView(test_proto).getUint8(i));
        }

    </script>
</head>

<body>
    Hello World!
</body>

</html>